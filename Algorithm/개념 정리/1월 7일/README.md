## 1월 7일(월) 알고리즘



**예전 삼성 알고리즘 등급**

> 1. IM (백트래킹까지)
> 2. AD (DP 심화 문제)
> 3. Pro (AD를 푸는 문제 중에 빠른 알고리즘을 알고 있어야)
> 4. Expert (시간 안에 답을 구할 수 없는 코드) : 대안으로 최대한 비슷한 답을 찾아가게 하는 기법을 사용



**현재**

> 한 단계씩 내려갔다고 생각하면 됨
>
> DP가 많이 사라지는 추세



### 배열1 (Array 1)

---

- 알고리즘
- 배열
- 완전검색
- 그리디
- 버블 정렬
- 카운팅 정렬



**좋은 알고리즘**

> 정확성, 작업량(big-O), 메모리 사용량, 단순성, 최적성



**시간 복잡도**

> 실행되는 명령문의 개수 계산
>
> 빅-오 표기법 : 가장 큰 영향력을 주는 **'n에 대한 항'**만 표시 (AD 등급부터 필요)
>
> `O(3n+2) = O(3n) = O(n)`
>
> `O(2n^2 + 10n + 100) = O(n^2)`



**정렬** 

> 카운팅 정렬이 가장 빠름 ( 음수면 양수로 바꿔서 할 수 있어야 함, 문자열 불가능 ) : O(n)
>
> 힙, 퀵, 머지 : O(nlogn)
>
> 선택,버블,삽입 : O(n^2)



##### 알고리즘 시험 보러 가면 완전 검색으로!

> 시간이 초과되면? 이를 개선시키는 다른 방안으로



**완전 검색**

> 모든 경우의 수를 나열 
>
> 순열 활용 (nPr)



##### 탐욕(그리디) 알고리즘

> 최적해를 구하는데 사용하는 방법





#### 알고리즘 설계 기법

---

- 완전검색 (Brute Force)

  > 처음부터 끝까지 모두 확인함 (전체 노가다 반복) : 시간이 가장 많이 걸림

- 탐욕기법 (Greedy)

  > 현재의 위치에서 최선의 선택
  > (증명이 필요, 답이 안 나올 가능성 존재ㅠㅠ)

- 가지치기 (Backtracking)

  > 답이 아닌 것의 탐색 제거

- 분할정복 (Divid & Conguer)

  > 정렬 후에 중간 값으로 비교 (아닌 곳은 다 자름) : O(logn)
  >
  > 부분해 → 전체 해

- 동적계획법(Dynamic Programming)



![1546846924499](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1546846924499.png)

데이터가 많을수록 유리한 정렬은 퀵 정렬!

라이브러리 sort는 모두 퀵 정렬로 구현되어있음

