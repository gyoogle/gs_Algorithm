## [운영체제] 동기화 (Synchronization)

<br/>

컴퓨터 통신 방식에는 두가지가 있다. 바로 `동기`와 `비동기`

동기는 영어로 Synchronous, 비동기는 Asynchronous

<br/>

최근 Web 수업에서 배운 **Ajax**의 첫번째 약자가 바로 비동기를 나타냄

요즘 홈페이지를 보면 동기와 비동기의 차이를 알 수 있음

과거에는 메뉴와 같은 버튼을 눌렀을 때, 모든 전체 페이지가 새로고침 되면서 결과가 나옴

하지만 요즘에는 전체적인 프레임은 유지한 채, 필요한 내부 데이터 부분만 갱신되는 사이트가 많아지는 추세

```
우리가 사이트에서 회원가입을 할 때, 따로 중복확인 버튼을 누르지 않아도 페이지 변화 없이 바로 중복여부를 아래 출력해주는 기능 또한 Ajax를 활용한 비동기 기법!
```

<br/>

**동기** : 응답을 받고 난 후 송신

**비동기** : 응답 여부 상관 없이 다시 전송

```
선생님 말씀이 끝날때까지 기다렸다가 대답하는 것이 '동기'
성호가 말하고 있는 도중에, 승아가 말하는 것이 '비동기' 
```

```
현아의 오늘 할 일 : 방 청소, 빨래, 엄마 심부름
동기 : 방 청소를 한다 → 빨래를 한다 → 엄마 심부름을 한다
비동기 : 방 청소를 오빠한테 시킨다/ 빨래방에 빨래를 맡긴다 / 심부름 업체에 시킨다
```



둘 중에 뭐가 더 좋은 거다라고 말할 수가 없음! 때에 따라 맞게 효율적으로 사용하자 

> 확실하게 응답을 받고 진행해야만 하는 것은 `동기`로
>
> 응답 받을 필요없이 빨리빨리빨리 진행해야 하는 것은 `비동기`로

<br/>

#### 프로세스 동기화

> 같이 협력하고 있는 프로세스 사이의 실행 순서 규칙을 보장하는 것을 말함
>
> 이로써, 공유되는 데이터의 일관성을 보장할 수 있도록 해줌

<br/>

동기화 처리를 해주지 않으면, 심각한 문제가 발생..!

<br/>

만약 아래와 같이 프로세스 P1, P2가 있다고 가정해보자

```
// P1
while(TRUE) {
    while (Counter == BUFFER_SIZE)
    Counter++;
}
```

```
// P2
while(TRUE) {
    while (Counter == BUFFER_SIZE)
    Counter--;
}
```

두 프로세스는 각각 Counter를 증가시켜주고 감소시켜주는 명령을 갖고있음

이 두 프로세스를 동시에 실행했을 때, 결과 값을 장담할 수 없게 되는 문제가 발생함

<br/>

컴파일 이후 기계어로 변환되는 과정은 아래와 같음

```
# P1의 경우
register1 = Counter
register1 = register + 1
Counter = register1

# P2의 경우
register2 = Counter
register2 = register - 1
Counter = register2
```

이는 바로 적용되는게 아니라, 인터럽트 처리기를 통해 메모리에 보관 후 적재 됨

이를 **동시에 실행한다는 것은, 기계어 코드가 뒤섞인 후에 순차적으로 실행**된다는 것과 마찬가지

<br/>

원하는 결과가 나올 수도 있고, 안 나올 수도 있기 때문에 매우 위험한 것

*Counter = 4*

```
T0 : register1 = Counter           -> register1 = 4
T1 : register1 = register + 1      -> register1 = 5
T2 : register2 = Counter           -> register2 = 4
T3 : register2 = register - 1       -> register2 = 3
T4 : Counter = register1          -> Counter = 5   
T5 : Counter = register2          -> Counter = 3  
```

T4와 T5를 보면, Counter의 값이 일정하지 않고 부정확한 결과가 나올 수 있음

<br/>

이처럼, 동일한 자료에 접근 및 조작하며 `순서`에만 의존하여 결과가 나타나는 현상을 **경쟁 상황(race condition)** 이라고 말함 (프로세스들이 서로 하나의 자료를 가지고 경쟁)

<br/>

이를 막기 위해서는?!

> 한 번에 하나의 프로세스만 접근하도록 허락을 내려줘야 됨

이것이 바로 동기화!!!!

**같은 메모리를 공유하는 멀티 스레드 환경**에서는 매우매우매우 필수적인 요소임

(스레드들이 메모리에 있는 자원들을 공유하고 있기 때문에.. 경쟁 상황으로 인해 사용자가 원하는 값이 나오지 않을 가능성 존재)

<br/>

<br/>

따라서 한 프로세스가 작업을 하고 있는 동안에는, 다른 프로세스가 경쟁하려고 달려들지 못하게 막아야 함 (데이터의 일관성을 보장하도록)

이러한 작업을 도와주는 것이 바로 **임계 영역(Critical Section)**

프로세스들은 각각 임계 구역 코드를 포함하고 있음!

<br/>

#### 임계 영역(Critical Section)

> 하나의 프로세스가 자신의 임계 영역에서 작업하는 동안에, 다른 프로세스가 그 임계 영역에 들어오지 못하도록 경쟁 상황을 막는 것

따라서 프로세스 구조 안에서 임계 영역에 대한 코드는 아래와 같은 구조로 이루어 짐

```
// 프로세스

do {
    <진입 영역(entry section)> // 임계 영역에 들어오는 부분
    <임계 영역(critical section)> // 임계 영역 진행 부분
    <퇴출 영역(exit section)> // 임계 영역에서 나가게 하는 부분
    
    <나머지 영역>
} while(true);
```



<br/>

이러한 임계 영역의 문제 해결방안에는 3가지 조건에 만족해야 함

1. 상호 배제 (Mutual Exclustion)
2. 진행(Progress)
3. 한정된 대기 (Bounded waiting)



이에 대한 자세한 설명은 다음 주에 계속~..